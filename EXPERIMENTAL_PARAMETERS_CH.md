# 实验参数配置文档

**版本**: 1.0  
**最后更新**: 2024  
**相关代码**: [`scripts/experiment_config.py`](scripts/experiment_config.py)  
**技术细节**: [`PRESENTATION_CH.md` 第710-829行](PRESENTATION_CH.md#L710-L829)

---

## 概述

本文档提供本研究中所有实验参数的完整规格说明。参数选择旨在系统性地评估防御机制在从理想到挑战性的各种网络条件下的性能表现。

---

## 核心参数

### 固定参数（所有实验通用）

| 参数 | 值 | 理由 |
|------|-----|------|
| `runs` | 200 | 蒙特卡洛迭代次数，达到95%置信水平 |
| `num_legit` | 20 | 每次运行的合法包数量（典型IoT通信周期） |
| `num_replay` | 100 | 每次运行的重放攻击次数（5:1攻击比例） |
| `seed` | 42 | 固定随机数种子，确保可重现性 |
| `attack_mode` | `post` | 事后攻击调度（实验1-2） |
| `attacker_loss` | 0.0 | 理想攻击者假设（无记录丢失） |

### 可变参数（实验特定）

| 实验 | 可变参数 | 范围 | 固定条件 | 输出 |
|------|---------|------|---------|------|
| 实验1 | `p_loss` | 0.0 - 0.30（步长0.05） | `p_reorder=0.0` | Figure 1 |
| 实验2 | `p_reorder` | 0.0 - 0.30（步长0.05） | `p_loss=0.10` | Figure 2 |
| 实验3 | `window_size` | 1, 3, 5, 7, 9, 15, 20 | `p_loss=0.15, p_reorder=0.15` | Figure 3 |

---

## 实验1：丢包率影响

**目标**：评估不同防御机制在不同丢包条件下的可用性表现。

**配置**：
```python
p_loss = [0.0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30]
p_reorder = 0.0
window_size = 5
attack_mode = "post"
runs = 200
seed = 42
```

**参数范围设计**：

| 丢包率 | 网络条件 | 应用场景 |
|--------|---------|---------|
| 0.0 (0%) | 理想信道 | 基准性能评估 |
| 0.05 (5%) | 良好室内 | 短距离、最小干扰 |
| 0.10 (10%) | 典型环境 | 常见IoT部署场景 |
| 0.15 (15%) | 较差环境 | 存在中等干扰 |
| 0.20 (20%) | 恶劣环境 | 工业环境存在障碍物 |
| 0.25 (25%) | 严重干扰 | 强电磁干扰 |
| 0.30 (30%) | 压力测试 | 实用评估的上限 |

**0-30%范围的理由**：
- 包含理想基准（0%）用于理论性能对比
- 覆盖典型IoT场景（5-15%）
- 扩展到挑战性条件（15-30%）用于鲁棒性评估
- 在大多数常见IoT部署中，超过30%的丢包率会让上层应用难以正常工作，因此我们将30%作为本研究的压力测试上限

**预期结果**（定性）：
- 无防御：攻击成功率保持高位（所有丢包率）
- 滚动计数器：可用性随丢包率下降（防御机制不会额外降低可用性）
- 滑动窗口：可用性下降趋势与滚动计数器相似（无乱序时）
- 挑战-响应：可用性受双向通信开销影响，但安全性最佳

*注：上述为设计阶段的定性预期，具体数值见实验结果部分。*

**重现方法**：
```bash
python scripts/run_sweeps.py \
  --runs 200 --seed 42 \
  --p-loss-values 0.0 0.05 0.10 0.15 0.20 0.25 0.30 \
  --p-loss-output results/p_loss_sweep.json
```

**输出文件**：
- 数据：`results/p_loss_sweep.json`
- 图表：`figures/p_loss_legit.png`, `figures/p_loss_attack.png`

---

## 实验2：乱序率影响

**目标**：展示滑动窗口对乱序的鲁棒性以及滚动计数器的脆弱性。

**配置**：
```python
p_reorder = [0.0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30]
p_loss = 0.10
window_size = 5
attack_mode = "post"
runs = 200
seed = 42
```

**为什么固定 p_loss = 0.10？**  
为了隔离乱序的影响，我们将丢包率固定在代表性的10%（典型IoT环境）。这遵循实验设计中的单变量控制原则。

**参数范围设计**：

| 乱序率 | 网络拓扑 | 特征 |
|--------|---------|------|
| 0.0 (0%) | 单跳理想 | 直接通信，无缓冲 |
| 0.05 (5%) | 单跳实际 | 轻微MAC重传延迟 |
| 0.10 (10%) | 2跳网络 | 缓冲队列引入少量乱序 |
| 0.15 (15%) | 3跳网络 | 多跳转发产生延迟抖动 |
| 0.20 (20%) | 多跳压力 | 显著的延迟变化 |
| 0.25 (25%) | 复杂拓扑 | 多路径路由、负载不均 |
| 0.30 (30%) | 压力测试 | 极端乱序用于鲁棒性评估 |

**预期结果**（定性）：
- 滚动计数器：可用性随乱序率显著下降（严格顺序检查导致乱序包被误判）
- 滑动窗口：可用性保持稳定（设计用于容忍窗口内乱序）
- 挑战-响应：受乱序影响，可用性有所下降

*注：本实验旨在揭示严格基于计数器的防御对乱序的敏感性，具体数值见PRESENTATION_CH.md第8.3节。*

**重现方法**：
```bash
python scripts/run_sweeps.py \
  --runs 200 --seed 42 \
  --p-reorder-values 0.0 0.05 0.10 0.15 0.20 0.25 0.30 \
  --p-reorder-output results/p_reorder_sweep.json
```

**输出文件**：
- 数据：`results/p_reorder_sweep.json`
- 图表：`figures/p_reorder_legit.png`, `figures/p_reorder_attack.png`

---

## 实验3：窗口大小权衡

**目标**：确定平衡安全性和可用性的最优滑动窗口大小。

**配置**：
```python
window_size = [1, 3, 5, 7, 9, 15, 20]
p_loss = 0.15
p_reorder = 0.15
attack_mode = "inline"
runs = 200
seed = 42
```

**为什么使用内联攻击模式？**  
内联攻击（在合法流量期间注入重放）比事后攻击更难防御。这为窗口大小权衡提供了更严格的评估。

**为什么 p_loss = p_reorder = 0.15？**  
中等网络压力（15%丢包和乱序）创造了真实的挑战性条件，使安全性和可用性之间的权衡最易观察。

**窗口大小权衡分析**：

| 窗口大小 | 安全性 | 可用性 | 说明 |
|---------|--------|--------|------|
| 1 | 最高 | 最低 | 严格顺序，任何延迟都会被拒绝 |
| 3 | 高 | 低 | 容忍2个包乱序 |
| **5** | **平衡** | **平衡** | **推荐值：良好的安全性和可用性** |
| 7 | 良好 | 良好 | 更高容忍度，安全性仍可接受 |
| 9 | 中等 | 高 | 良好可用性，安全性开始下降 |
| 15 | 低 | 很高 | 窗口过大，重放窗口增加 |
| 20 | 很低 | 最高 | 接近无防御场景 |

**预期结果**（定性）：
- 可用性：随窗口大小增加而上升（窗口过小导致大量乱序包被拒绝）
- 攻击成功率：随窗口大小增加而上升（更大窗口为攻击者提供更多重放机会）
- 预期存在最优平衡点：窗口适中时可兼顾可用性和安全性

*注：上述为参数设计阶段的定性预期，最终实测结果见PRESENTATION_CH.md第8.4节。*

**重现方法**：
```bash
python scripts/run_sweeps.py \
  --runs 200 --seed 42 \
  --window-values 1 3 5 7 9 15 20 \
  --attack-mode inline \
  --window-output results/window_sweep.json
```

**输出文件**：
- 数据：`results/window_sweep.json`
- 图表：`figures/window_tradeoff.png`

---

## 参数范围论证

### 统计学考虑

**蒙特卡洛运行次数（n=200）**：
- 置信水平：95%（α = 0.05）
- 标准误差：±2-3%
- 足以观察防御机制之间的统计显著性差异
- 性能：200次运行约5.3秒（实测）

**合法包数量（n=20）**：
- 代表典型IoT通信会话（例如传感器每10秒上报一次，持续3-5分钟）
- 平衡真实性与计算效率
- 所有实验固定以确保公平比较

**重放攻击次数（n=100）**：
- 5:1的攻击-合法比例代表高威胁场景
- 足够的样本量用于准确估计攻击成功率
- 符合安全评估最佳实践

### 网络参数范围

**重要说明**：本研究中使用的具体数值范围（例如"0-30%丢包率"）是**为系统评估设计的仿真参数**，而非任何单一文献来源的直接测量值。这些范围通过以下方式设计：

1. **文献背景**：参考IEEE 802.15.4、LoRaWAN和BLE部署中关于短距离无线网络可靠性的定性描述
2. **覆盖原则**：从理想到挑战性条件的完整跨度，以全面表征防御机制行为
3. **实用相关性**：聚焦于网络保持可用的范围（排除极端失败场景）

**参考背景文献**（定性背景）：
- IEEE 802.15.4/ZigBee：Baronti et al. (2007) - 工业环境变化性
- LoRaWAN：Haxhibeqiri et al. (2018) - 城市部署挑战
- BLE：Gomez et al. (2012) - 2.4GHz干扰影响
- 工业WSN：Sha et al. (2017) - 工厂可靠性研究

详细讨论：[`PRESENTATION_CH.md` 第710-829行](PRESENTATION_CH.md#L710-L829)

---

## 可重现性

所有实验使用 `seed=42` 以确保跨运行的相同结果。完整工作流程：

1. 运行参数扫描：`python scripts/run_sweeps.py --runs 200 --seed 42`
2. 生成图表：`python scripts/plot_results.py`
3. 导出表格：`python scripts/export_tables.py`

结果保存为JSON文件在 `results/` 目录中，包含完整配置元数据。

---

## 实现

本文档中定义的参数在以下位置实现：
- 代码配置：[`scripts/experiment_config.py`](scripts/experiment_config.py)
- 执行脚本：[`scripts/run_sweeps.py`](scripts/run_sweeps.py)
- 信道模型：[`sim/channel.py`](sim/channel.py)

测试参数配置：
```bash
python scripts/experiment_config.py  # 打印参数摘要
```

---

## 版本历史

**v1.0**（2024）
- 初始参数规格说明
- 定义三个核心实验
- 记录统计论证

---

## 参考文献

详细技术实现和理论背景，请参考：
- 主要文档：[`PRESENTATION_CH.md`](PRESENTATION_CH.md)
- 项目README：[`README_CH.md`](README_CH.md)
- 代码仓库：[GitHub](https://github.com/tammakiiroha/Replay-simulation)

