# 项目演示：重放攻击仿真工具包

**Presenter**: Romeitou  
**Project URL**: https://github.com/tammakiiroha/Replay-simulation  
**Language**: Python 3.11+  
**License**: MIT

---

## Table of Contents

1. [Project Overview](#1-project-overview)
2. [Research Background and Motivation](#2-research-background-and-motivation)
3. [System Architecture](#3-system-architecture)
4. [Defense Mechanism Details](#4-defense-mechanism-details)
5. [Evaluation Metrics Explanation](#5-evaluation-metrics-explanation)
6. [Technical Implementation Details](#6-technical-implementation-details)
7. [Experimental Design and Methodology](#7-experimental-design-and-methodology)
8. [Key Experimental Results](#8-key-experimental-results)
9. [Glossary](#9-glossary)
10. [Demonstration](#10-demonstration)

---

## 1. Project Overview

### 1.1 Project Purpose

A simulation toolkit for quantitative evaluation of **4 types of defense mechanisms** against replay attacks in wireless control systems (e.g., IoT devices, smart homes, industrial control).

### 1.2 Problem Being Solved

**Challenges**:
- In wireless communication, attackers can intercept and record frames, then retransmit them later (replay)
- Under realistic conditions with packet loss and reordering, it's unclear which defense mechanism is optimal

**Our Contribution**:
- Quantitative evaluation of defense performance under realistic channel conditions (packet loss, reordering)
- Visualization of security (attack success rate) vs usability (legitimate acceptance rate) tradeoffs
- Fully reproducible with 1500 lines of Python code

---

## 2. Research Background and Motivation

### 2.1 What is a Replay Attack?

```
┌─────────────────────────────────────────────────┐
│ Legitimate User      Wireless Channel            │
│  [Sender]  ─────→  "UNLOCK" ─────→  [Receiver]  │
│                      ↓                           │
│                   [Attacker]                      │
│                   Record & Save                   │
│                      ↓                           │
│  Later replay:  "UNLOCK" ─────→  [Receiver]     │
│              Door opens!                          │
└─────────────────────────────────────────────────┘
```

**Threats**:
- Smart lock: Attacker replays "unlock" command
- Vehicle: Replay "start engine" command for theft
- Industrial control: Disrupt "stop" commands

### 2.2 Why Do We Need Simulation?

**Challenges of Physical Experiments**:
- High cost (multiple devices, RF environment setup)
- Time-consuming (hundreds of trials needed)
- Difficult to ensure reproducibility

**Advantages of Simulation**:
- Complete control and reproducibility (fixed random seeds)
- Rapid iterative experiments (200 trials in seconds)
- Free parameter adjustment

---

## 3. System Architecture

### 3.1 Overall Architecture Diagram

```mermaid
graph TB
    subgraph "Input Layer"
        A[Command Sequence<br/>traces/sample_trace.txt]
        B[Simulation Config<br/>SimulationConfig]
    end
    
    subgraph "Simulation Layer"
        C[Sender<br/>Sender]
        D[Channel<br/>Channel]
        E[Receiver<br/>Receiver]
        F[Attacker<br/>Attacker]
    end
    
    subgraph "Evaluation Layer"
        G[Statistics Aggregation<br/>RunStats]
        H[Visualization<br/>Matplotlib]
    end
    
    subgraph "Output Layer"
        I[JSON Results<br/>results/*.json]
        J[PNG Figures<br/>figures/*.png]
    end
    
    A --> C
    B --> C
    C --> D
    D --> E
    D --> F
    F --> E
    E --> G
    G --> H
    G --> I
    H --> J
```

### 3.2 Key Components

| Component | File | Responsibility |
|-----------|------|----------------|
| **Sender** | `sim/sender.py` | Frame generation, counter/MAC attachment |
| **Channel** | `sim/channel.py` | Simulate packet loss and reordering |
| **Receiver** | `sim/receiver.py` | Verification logic for each defense mode |
| **Attacker** | `sim/attacker.py` | Frame recording and selective replay |
| **Experiment Control** | `sim/experiment.py` | Monte Carlo trial management |
| **Data Types** | `sim/types.py` | Common data structures (Frame, Config, etc.) |

---

## 4. Defense Mechanism Details

This project implements and compares 4 types of defense mechanisms.

### 4.1 No Defense - Baseline

**Implementation**:
```python
def verify_no_defense(frame, state):
    return VerificationResult(True, "accept", state)
```

**Characteristics**:
- Accepts all frames
- Security: ❌ 0% (all replays succeed)
- Usability: ✅ 100%

**Purpose**: Baseline for measuring attack impact

---

### 4.2 Rolling Counter + MAC

**Principle**:
```
Sender: Counter = 0, 1, 2, 3, 4, ...
Receiver: Last = -1
        Frame Counter=0 arrives → 0 > -1 ✅ Accept, Last=0
        Frame Counter=1 arrives → 1 > 0 ✅ Accept, Last=1
        Replay Counter=0 arrives → 0 ≤ 1 ❌ Reject (replay detected)
```

**Implementation Key Points**:
```python
def verify_with_rolling_mac(frame, state, shared_key, mac_length):
    # 1. MAC verification (tamper prevention)
    expected_mac = compute_mac(frame.command, frame.counter, shared_key)
    if not constant_time_compare(frame.mac, expected_mac):
        return VerificationResult(False, "mac_mismatch", state)
    
    # 2. Counter monotonic increase check
    if frame.counter <= state.last_counter:
        return VerificationResult(False, "counter_replay", state)
    
    # 3. Accept and update state
    state.last_counter = frame.counter
    return VerificationResult(True, "accept", state)
```

**What is MAC (Message Authentication Code)**:
- Uses HMAC-SHA256
- Generates signature with shared key to detect tampering
- Attacker cannot forge valid MAC

**Advantages**:
- ✅ Completely prevents replay attacks (under ideal channel)
- ✅ Simple implementation

**Disadvantages**:
- ❌ Weak against packet reordering
- Example: Frame 5 arrives first → Last=5
     Then Frame 4 arrives → 4 < 5 rejected (false positive)

---

### 4.3 Sliding Window

**Principle**: Allow a "range" of counters to handle reordering

```
Window Size = 5 example:

Last Counter = 10, Received bitmask = 0b10101

Acceptable range: [6, 7, 8, 9, 10]
         └────5 items────┘

Frame Counter=8 arrives:
  - 8 is within range ✅
  - Bit position offset = 10 - 8 = 2
  - Check bit 2 of mask → 0 so not received ✅
  - Set bit 2 → 0b10101 | (1 << 2) = 0b10101 ✅ Accept
```

**Core Bitmask Implementation**:
```python
def verify_with_window(frame, state, window_size):
    diff = frame.counter - state.last_counter
    
    if diff > 0:  # New maximum counter
        state.received_mask <<= diff       # Shift window
        state.received_mask |= 1           # Mark new position
        state.last_counter = frame.counter
        return VerificationResult(True, "accept_new", state)
    
    else:  # Old counter (reordered)
        offset = -diff
        if offset >= window_size:
            return VerificationResult(False, "too_old", state)
        
        if (state.received_mask >> offset) & 1:
            return VerificationResult(False, "replay", state)
        
        state.received_mask |= (1 << offset)
        return VerificationResult(True, "accept_old", state)
```

**Bitmask Meaning**:
```
state.received_mask = 0b10101
                       ↑↑↑↑↑
                       │││││
                       │││││
    bit 4 (Counter 6): │││││ = 1 (received)
    bit 3 (Counter 7): ││││  = 0 (not received)
    bit 2 (Counter 8): │││   = 1 (received)
    bit 1 (Counter 9): ││    = 0 (not received)
    bit 0 (Counter 10):│     = 1 (received, Last)
```

**Advantages**:
- ✅ Handles reordering (99.9% legitimate acceptance with W=5)
- ✅ High security (replay success rate < 0.5%)

**Disadvantages**:
- ⚠️ Window too small causes false positives
- ⚠️ Window too large reduces security

---

### 4.4 Challenge-Response

**Principle**: Receiver sends a "challenge (nonce)", sender returns "response"

```
Receiver → Sender:  "Nonce: 0x3a7f" (random value)
Sender → Receiver:  "Command: UNLOCK, Nonce: 0x3a7f, MAC: ..."

Receiver: Accept if nonce matches and MAC is correct
       Replayed frames have old nonces and are rejected
```

**Implementation**:
```python
def verify_with_challenge(frame, state):
    if frame.nonce != state.expected_nonce:
        return VerificationResult(False, "nonce_mismatch", state)
    
    # Generate new nonce (for next time)
    state.expected_nonce = generate_random_nonce()
    return VerificationResult(True, "accept", state)
```

**Advantages**:
- ✅ Highest security (0% attack success rate)
- ✅ No impact from reordering

**Disadvantages**:
- ❌ Requires bidirectional communication (unusable for unidirectional systems)
- ❌ High latency (round-trip communication)

---

## 5. Evaluation Metrics Explanation

### 5.1 Legitimate Acceptance Rate

**Definition**: Proportion of legitimate transmitted frames accepted by receiver

$$
\text{Legitimate Acceptance Rate} = \frac{\text{Accepted legitimate frames}}{\text{Transmitted legitimate frames}} \times 100\%
$$

**Meaning**:
- **Usability metric**
- Higher is better (closer to 100%)
- Decreases with packet loss and reordering

**Example**:
```
Transmitted: 20 frames
Accepted: 19 frames (1 frame rejected due to reordering)
Legitimate acceptance rate = 19/20 = 95%
```

---

### 5.2 Attack Success Rate

**Definition**: Proportion of attacker's replay frames that are accepted

$$
\text{Attack Success Rate} = \frac{\text{Accepted replay frames}}{\text{Replay attempts}} \times 100\%
$$

**Meaning**:
- **Security metric**
- Lower is better (closer to 0%)
- Ideally 0%

**Example**:
```
Replay attempts: 100 frames
Accepted: 2 frames (exploited defense gaps)
Attack success rate = 2/100 = 2%
```

---

### 5.3 Tradeoff Visualization

```
┌────────────────────────────────────────────────┐
│                                                │
│  100%  ●                           ● Challenge│
│   Leg  │ ╲                    ╱              │
│   Acc  │   ╲                ╱                │
│   Rate │     ● Window     ●                  │
│        │      (W=5)   Rolling                │
│        │                                     │
│    0%  ●──────────────────────────────────── │
│       0%     Attack Success Rate     100%    │
│                                                │
│   Ideal: Top-left (High usability, Low attack)│
└────────────────────────────────────────────────┘
```

---

## 6. Technical Implementation Details

### 6.1 Channel Model

**Problem**: Real wireless communication is not perfect
- Packets are lost (p_loss)
- Packets are reordered (p_reorder)

**Implementation**: Delay simulation using priority queue

```python
class Channel:
    def __init__(self, p_loss, p_reorder, rng):
        self.p_loss = p_loss
        self.p_reorder = p_reorder
        self.pq = []  # Priority queue (heap)
        self.current_tick = 0
    
    def send(self, frame):
        # 1. Packet loss
        if self.rng.random() < self.p_loss:
            return []  # Discard frame
        
        # 2. Reordering (probabilistic delay)
        if self.rng.random() < self.p_reorder:
            delay = self.rng.randint(1, 3)  # 1-3 tick delay
        else:
            delay = 0
        
        delivery_tick = self.current_tick + delay
        heapq.heappush(self.pq, (delivery_tick, frame))
        
        # 3. Return frames due for delivery at current tick
        return self._deliver_due_frames()
```

**Why This Matters**:
- Rolling Counter is weak against reordering
- Window was designed to solve this problem

---

### 6.2 Monte Carlo Simulation

**Why Needed?**
- Statistical evaluation of random effects (packet loss, reordering)

**Implementation**:
```python
def run_many_experiments(config, num_runs):
    results = []
    for run_id in range(num_runs):
        result = simulate_one_run(config, run_id)
        results.append(result)
    
    # Calculate mean and standard deviation
    avg_legit = mean([r.legit_accept_rate for r in results])
    std_legit = stdev([r.legit_accept_rate for r in results])
    
    return AggregateStats(avg_legit, std_legit, ...)
```

**Statistical Reliability**:
- 200-500 trials to calculate standard deviation
- Error bars show confidence intervals

---

### 6.3 Attacker Model

**2 Types of Attack Timing**:

#### Post-run Attack
```python
# Replay in batch after legitimate communication ends
legit_phase()   # Send 20 frames
attack_phase()  # Replay 100 frames
```

#### Inline Attack
```python
# Mix replays during legitimate communication (more realistic)
for frame in legit_frames:
    send(frame)
    if random() < 0.3:  # 30% probability
        replay(recorded_frame)  # Immediate replay
```

**Selective Replay**:
```python
attacker = Attacker(target_commands=["UNLOCK", "FIRE"])
# Only replay "UNLOCK" and "FIRE"
# Ignore harmless commands like "STATUS"
```

---

## 7. Experimental Design and Methodology

### 7.1 Parameter Sweeps

**Purpose**: Systematically evaluate performance under different conditions

#### Sweep 1: Packet Loss Rate (p_loss)
```python
p_loss_values = [0.0, 0.01, 0.05, 0.10, 0.20]
p_reorder = 0.0  # Fixed
```

**Finding**: Rolling and Window have same performance (without reordering)

#### Sweep 2: Packet Reordering Rate (p_reorder)
```python
p_reorder_values = [0.0, 0.1, 0.3, 0.5, 0.7]
p_loss = 0.0  # Fixed
```

**Finding**: Rolling drops to 84% at p_reorder=0.3, Window maintains 99.9%

#### Sweep 3: Window Size (window_size)
```python
window_values = [1, 3, 5, 10]
p_loss = 0.05, p_reorder = 0.3  # Stress test
```

**Finding**: W=1 is catastrophic (27%), W=3-5 is optimal (95%)

---

### 7.2 Experimental Reproducibility

**Random Seed Management**:
```python
config = SimulationConfig(
    rng_seed=123,  # Fixed seed
    ...
)
```

Same seed used across all experiments → Fully reproducible

**Fair Comparison**:
```python
# Use same random sequence for all modes
rng = random.Random(seed)
for mode in [no_def, rolling, window, challenge]:
    rng.seed(seed)  # Reset each time
    run_experiment(mode, rng)
```

---

## 8. Key Experimental Results

### 8.1 Resistance to Reordering (p_loss=0)

**Experimental Purpose**:
Measure the impact of packet reordering on legitimate acceptance rate and quantify the performance difference between Rolling Counter and Sliding Window.

**Experimental Setup**:
- Number of trials: 200 (Monte Carlo)
- Legitimate frames per trial: 20
- Replay attempts per trial: 100
- Packet loss rate: p_loss = 0 (no loss, purely measure reordering impact)
- Packet reordering rate: p_reorder = 0.0, 0.1, 0.3, 0.5, 0.7 (gradual increase)

**Data Source**: `results/p_reorder_sweep.json`

| p_reorder | Rolling (%) | Window (W=5) (%) | Difference | Interpretation |
|-----------|-------------|------------------|------------|----------------|
| 0.0 | 100.00 | 100.00 | 0 | No reordering: both perfect |
| 0.1 | 93.55 | 100.00 | **+6.45** | 10% delay probability: Window unaffected |
| 0.3 | 84.47 | 99.88 | **+15.41** | ⚠️ Rolling significantly degraded |
| 0.5 | 77.62 | 99.88 | **+22.26** | ⚠️ 1/4 of Rolling frames rejected |
| 0.7 | 78.33 | 99.90 | **+21.57** | ⚠️ Rolling unusable |

**Visualization**:

![Impact of Packet Reordering](figures/p_reorder_legit.png)

**How to Read the Figure**:
- **X-axis**: p_reorder (packet reordering probability)
  - 0.0 = perfect network (no reordering)
  - 0.7 = very unstable network (70% of frames delayed)
- **Y-axis**: Legitimate Acceptance Rate (%)
  - 100% = all legitimate frames accepted (ideal)
  - 0% = all legitimate frames rejected (system unusable)
- **Blue line (circle markers)**: Rolling Counter
  - Drops sharply as p_reorder increases
  - At p_reorder=0.3: 84% (16% of legitimate frames wrongly rejected)
- **Orange line (triangle markers)**: Sliding Window (W=5)
  - Nearly flat as p_reorder increases (maintains 99.9%)
  - Extremely robust against reordering
- **Error bars (vertical lines)**: Standard deviation
  - Shows variation across 200 trials
  - Short bars = stable results (high reliability)

**Important Findings**:
1. **Rolling Counter Limitation**:
   - At p_reorder=0.3 (moderate instability), legitimate acceptance rate drops to **84.47%**
   - This means **16% of legitimate users are rejected**
   - Example: 16 out of 100 legitimate operations fail → user frustration

2. **Sliding Window Advantage**:
   - Even at p_reorder=0.7 (extreme instability), maintains **99.90%**
   - Window mechanism allows delayed frames to still be accepted

3. **Practical Impact**:
   - Wi-Fi and Bluetooth typically have p_reorder=0.1~0.3
   - In this environment, Rolling causes 6~15% usability degradation
   - Window ensures security without sacrificing usability

**Conclusion**:
- Window is **extremely robust** against reordering
- Rolling has **15% usability degradation** at p_reorder=0.3
- **Sliding Window is essential for unstable networks**

---

### 8.2 Window Size Impact (p_loss=0.05, p_reorder=0.3)

**Experimental Purpose**:
Determine optimal window size and visualize usability-security tradeoff.

**Experimental Setup**:
- Number of trials: 200
- Stress test conditions: p_loss=0.05 (5% loss), p_reorder=0.3 (30% reordering)
- Window sizes: W = 1, 3, 5, 10

| Window Size | Legit Accept (%) | Attack Success (%) |
|-------------|------------------|--------------------|
| W=1         | 27.65            | 4.51               |
| W=3         | **95.10**        | 0.22               |
| W=5         | **95.08**        | 0.30               |
| W=10        | **95.22**        | 0.48               |

**Visualization**:

![Window Size Tradeoff](figures/window_tradeoff.png)

**How to Read the Figure**:
- **Left side (blue bars)**: Legitimate acceptance rate (higher is better)
- **Right side (orange bars)**: Attack success rate (lower is better)
- **W=1**: High security but catastrophic usability (27.65%)
- **W=3-5**: Optimal balance (95% usability, <0.5% attack rate)
- **W=10**: Marginal usability improvement, increased security risk

**Optimal Solution**: W=3~5
- Usability: 95% (sufficiently high)
- Security: Attack success rate < 0.5% (very low)

---

### 8.3 Comprehensive Defense Comparison (Ideal Channel)

| Mode         | Legit Accept | Attack Success | Bidirectional | Implementation |
|--------------|--------------|----------------|---------------|----------------|
| No Defense   | 100%         | **100%** ❌     | Not required  | Simple         |
| Rolling      | 100%         | 0% ✅           | Not required  | Simple         |
| Window (W=5) | 100%         | 0% ✅           | Not required  | Medium         |
| Challenge    | 100%         | 0% ✅           | **Required** ⚠️| Medium         |

**Comparison Under Realistic Channel (p_reorder=0.3)**:

| Mode         | Legit Accept | Attack Success | Recommended |
|--------------|--------------|----------------|-------------|
| Rolling      | 84.47%       | 0%             | ⚠️ Low      |
| Window (W=5) | 99.88%       | 0%             | ✅ High     |
| Challenge    | 100%         | 0%             | ✅ Best (if bidirectional possible) |

**Visualization**:

![Baseline Attack Success Comparison](figures/baseline_attack.png)

**How to Read the Figure**:
- Compares **4 defense modes** under ideal conditions (p_loss=0, p_reorder=0)
- **Y-axis**: Attack success rate (lower is better)
- **No Defense (red)**: 100% attack success (all replays succeed)
- **Rolling/Window/Challenge (blue/green/purple)**: All 0% (complete defense)
- This figure shows "all defense mechanisms are effective under ideal conditions"
- However, under realistic conditions (with reordering), Window is superior (see Figure 1)

---

### 8.4 Packet Loss Impact (Legitimate Acceptance)

**Experimental Purpose**:
Measure the impact of packet loss on legitimate acceptance rate.

**Experimental Setup**:
- p_loss = 0.0, 0.01, 0.05, 0.10, 0.20
- p_reorder = 0 (no reordering)

**Visualization**:

![Packet Loss Impact (Legitimate Acceptance)](figures/p_loss_legit.png)

**How to Read the Figure**:
- **X-axis**: p_loss (packet loss probability)
- **Y-axis**: Legitimate acceptance rate
- **Important Finding**: Rolling and Window have **same performance**
  - p_loss=0.05: Both at 94.88%
  - p_loss=0.20: Both at 79.53%
- **Reason**: Without reordering, Window has no advantage
- Packet loss equally affects both methods

---

### 8.5 Packet Loss Impact (Attack Success)

**Experimental Purpose**:
Measure the impact of packet loss on attack success rate.

**Visualization**:

![Packet Loss Impact (Attack Success)](figures/p_loss_attack.png)

**How to Read the Figure**:
- **X-axis**: p_loss (packet loss probability)
- **Y-axis**: Attack success rate (lower is better)
- **All modes have attack success rate ≈ 0%**
- Packet loss also affects attacker (replayed frames are lost too)
- Defense remains effective regardless of loss rate

---

## 9. Glossary

### A-F

**Acceptance Rate**
- Proportion of frames accepted by receiver
- Two types: legitimate acceptance (usability) and attack success (security)

**Attack Mode**
- Post: Batch replay after legitimate communication
- Inline: Mix replays during legitimate communication

**Bitmask**
- Integer recording received counters in sliding window
- Example: 0b10101 → bits 0, 2, 4 received

**Challenge-Response**
- Authentication method where receiver sends challenge (nonce) and sender returns response

**Counter**
- Integer incrementing with each frame (0, 1, 2, 3, ...)
- Used for replay detection

**Frame**
- Minimum unit of wireless communication
- Structure: `{command, counter, mac, nonce}`

### G-M

**HMAC (Hash-based Message Authentication Code)**
- Message authentication code using shared key
- This project uses HMAC-SHA256

**Inline Attack**
- Attack executing replays simultaneously with legitimate communication

**Legitimate Traffic**
- Communication from legitimate users

**MAC (Message Authentication Code)**
- Short code ensuring message integrity and authenticity
- Attacker cannot forge valid MAC

**Monte Carlo Simulation**
- Statistical simulation using random numbers
- This project uses 200-500 trials to calculate confidence intervals

### N-Z

**Nonce**
- Abbreviation for "Number used ONCE"
- Random value used only once
- Used for replay prevention

**Packet Loss**
- Phenomenon where frames are lost in wireless communication
- p_loss: Loss probability (0.0 = no loss, 0.2 = 20% loss)

**Packet Reordering**
- Phenomenon where frames arrive in different order than sent
- p_reorder: Reordering probability

**Replay Attack**
- Attack retransmitting previously intercepted frames

**Rolling Counter**
- Method rejecting old frames using monotonically increasing counter

**Sliding Window**
- Method handling reordering by allowing counter range
- Records received counters using bitmask

**Seed**
- Initial value for random number generator
- Same seed enables experiment reproduction

---

## 10. Demonstration

### 10.1 Quick Demo (5 minutes)

**Step 1: Basic Execution**
```bash
python3 main.py --runs 10 --num-legit 10 --num-replay 20 \
                --modes rolling window --p-loss 0.05
```

**Sample Output**:
```
Mode     Runs  Attack  p_loss  Window  Avg Legit  Avg Attack
-------  ----  ------  ------  ------  ---------  ----------
rolling  10    post    0.05    0        96.00%      0.00%
window   10    post    0.05    5        96.00%      0.50%
```

**Key Points**:
- Rolling and Window have same legitimate acceptance (packet loss only)
- Both have high security

---

**Step 2: Reordering Impact**
```bash
python3 main.py --runs 10 --num-legit 20 --num-replay 50 \
                --modes rolling window --p-reorder 0.3
```

**Sample Output**:
```
Mode     Runs  Attack  p_reorder  Window  Avg Legit  Avg Attack
-------  ----  ------  ---------  ------  ---------  ----------
rolling  10    post    0.30       0        82.50%      0.00%
window   10    post    0.30       5        99.50%      0.00%
```

**Key Points**:
- Rolling legitimate acceptance **drops 17%**
- Window nearly unaffected (99.5%)

---

### 10.2 Figure Demo (3 minutes)

**Figure 1: Packet Reordering Impact**
```bash
python3 scripts/plot_results.py --formats png
```

File: `figures/p_reorder_legit.png`

**Key Points**:
- X-axis: p_reorder (reordering probability)
- Y-axis: Legitimate acceptance rate
- Blue line (Rolling): Sharp decline
- Orange line (Window): Nearly flat

---

**Figure 2: Window Size Tradeoff**
```bash
open figures/window_tradeoff.png
```

**Key Points**:
- W=1: Low usability (27%), high security (4.5%)
- W=3-5: **Optimal balance** (95% / 0.3%)
- W=10: Marginal usability increase, slight security decrease

---

### 10.3 Code Walkthrough (5 minutes)

**Demo 1: Sliding Window Operation**

```python
# Open sim/receiver.py
def verify_with_window(frame, state, window_size):
    diff = frame.counter - state.last_counter
    
    if diff > 0:  # New counter
        print(f"New maximum counter: {frame.counter}")
        state.received_mask <<= diff
        state.received_mask |= 1
        state.last_counter = frame.counter
        return VerificationResult(True, "accept_new", state)
```

**Key Points**:
1. `diff > 0`: Counter advanced → shift window
2. `received_mask <<= diff`: Left shift to remove old bits
3. `received_mask |= 1`: Mark current counter as received

---

**Demo 2: Channel Model Reordering**

```python
# Open sim/channel.py
def send(self, frame):
    if self.rng.random() < self.p_reorder:
        delay = self.rng.randint(1, 3)  # Random delay
        print(f"Frame {frame.counter} delayed by {delay} ticks")
    else:
        delay = 0
    
    delivery_tick = self.current_tick + delay
    heapq.heappush(self.pq, (delivery_tick, frame))
```

**Key Points**:
1. 30% probability of 1-3 tick delay
2. Priority queue (heap) manages delivery time
3. This naturally causes reordering

---

### 10.4 Q&A Preparation

**Expected Questions and Answers**:

**Q1: Why Python? Isn't C/C++ faster?**
> A: Simulation is computation-heavy, not I/O-bound. Python completes 200 trials in seconds. We prioritized readability and development speed.

**Q2: Comparison with physical experiments?**
> A: Physical experiments are future work. However, our channel model is based on literature (IEEE 802.11 packet loss model) and is realistic.

**Q3: Challenge-Response is strongest, why use other methods?**
> A: Challenge-Response requires bidirectional communication with high latency. Rolling/Window are more practical for IoT devices and low-power sensors.

**Q4: What is optimal window size?**
> A: Experimental results recommend W=3-5. However, actual systems need adjustment based on communication environment.

**Q5: What if attacker targets window gaps?**
> A: We measured this in experiments. Even with W=5, attack success rate is <0.3%, practically negligible.

---

## Appendix A: System Requirements

**Hardware**:
- CPU: Any (Apple Silicon / Intel / AMD)
- RAM: 2GB minimum
- Storage: 50MB

**Software**:
- Python 3.11+
- matplotlib >= 3.10 (visualization)
- pytest >= 7.0 (testing)

**OS**:
- macOS 14.x
- Ubuntu 22.04
- Windows 10/11 (WSL recommended)

---

## Appendix B: Directory Structure

```
Replay-simulation/
├── main.py                 # CLI entry point
├── README.md               # Main documentation (English)
├── README.ja.md            # Japanese documentation
├── README.zh.md            # Chinese documentation
├── PRESENTATION.md         # This presentation (Japanese)
├── PRESENTATION.en.md      # This presentation (English)
├── PRESENTATION.zh.md      # This presentation (Chinese)
├── requirements.txt        # Python dependencies
├── LICENSE                 # MIT License
│
├── sim/                    # Core simulation library
│   ├── types.py           # Data structures (Frame, Config, etc.)
│   ├── sender.py          # Sender logic
│   ├── receiver.py        # Receiver & verification logic
│   ├── channel.py         # Channel model
│   ├── attacker.py        # Attacker model
│   ├── experiment.py      # Experiment control
│   ├── security.py        # Cryptographic primitives
│   └── commands.py        # Command sequences
│
├── scripts/                # Automation scripts
│   ├── run_sweeps.py      # Parameter sweeps
│   ├── plot_results.py    # Figure generation
│   └── export_tables.py   # Markdown table generation
│
├── tests/                  # Unit tests
│   └── test_receiver.py   # Receiver logic tests
│
├── results/                # Experimental results (JSON)
│   ├── p_loss_sweep.json
│   ├── p_reorder_sweep.json
│   ├── window_sweep.json
│   ├── ideal_p0.json
│   └── trace_inline.json
│
├── figures/                # Generated figures (PNG)
│   ├── p_loss_legit.png
│   ├── p_loss_attack.png
│   ├── p_reorder_legit.png
│   ├── window_tradeoff.png
│   └── baseline_attack.png
│
└── traces/                 # Command traces
    └── sample_trace.txt   # Sample command sequence
```

---

## Appendix C: References

[1] Perrig, A., Szewczyk, R., Tygar, J. D., Wen, V., & Culler, D. E. (2002). SPINS: Security Protocols for Sensor Networks. *Wireless Networks*, 8(5), 521-534.

[2] Kent, S., & Seo, K. (2005). Security Architecture for the Internet Protocol. RFC 4301, Internet Engineering Task Force.

[3] Bellare, M., Canetti, R., & Krawczyk, H. (1996). Keying Hash Functions for Message Authentication. In *Advances in Cryptology—CRYPTO'96*, pp. 1-15. Springer.

[4] Needham, R. M., & Schroeder, M. D. (1978). Using Encryption for Authentication in Large Networks of Computers. *Communications of the ACM*, 21(12), 993-999.

[5] Tanenbaum, A. S., & Wetherall, D. J. (2011). *Computer Networks* (5th ed.). Prentice Hall.

[6] Syverson, P. (1994). A Taxonomy of Replay Attacks. In *Proceedings of Computer Security Foundations Workshop VII*, pp. 187-191. IEEE.

[7] Rescorla, E. (2018). The Transport Layer Security (TLS) Protocol Version 1.3. RFC 8446, IETF.

---

## Summary

### Project Contributions

1. Unified evaluation of 4 defense mechanisms
2. Realistic channel model (packet loss and reordering)
3. Quantitative evaluation (200-500 Monte Carlo trials)
4. Fully reproducible (fixed seeds, open source)
5. Visualization and documentation (publication-quality figures, 3-language documentation)

### Key Findings

1. **Rolling Counter Limitation**: 15% usability degradation in reordering environments
2. **Sliding Window Advantage**: 95% usability with <0.3% attack success rate at W=3-5
3. **Challenge-Response Role**: Highest security, but requires bidirectional communication

### Practical Recommendations

| System Characteristics | Recommended Defense |
|------------------------|---------------------|
| Unidirectional, stable network | Rolling Counter |
| Unidirectional, unstable network | **Sliding Window (W=5)** |
| Bidirectional, high security requirement | Challenge-Response |

---

**Thank you for your attention!**

**Contact**:
- GitHub: https://github.com/tammakiiroha/Replay-simulation
- Project License: MIT

**Questions are welcome!**

