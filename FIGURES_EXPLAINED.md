# 実験結果図表の詳細解説

このドキュメントは、プロジェクトで生成されたすべての図表について、各指標の意味と読み取り方を**超詳細**に解説します。

---

## 目次

1. [図1: パケット順序入れ替えの影響（p_reorder vs 正規受理率）](#図1-パケット順序入れ替えの影響)
2. [図2: パケット損失の影響（p_loss vs 正規受理率）](#図2-パケット損失の影響)
3. [図3: パケット損失の影響（p_loss vs 攻撃成功率）](#図3-パケット損失の影響攻撃成功率)
4. [図4: ウィンドウサイズのトレードオフ](#図4-ウィンドウサイズのトレードオフ)
5. [図5: ベースライン攻撃成功率比較](#図5-ベースライン攻撃成功率比較)

---

## 図1: パケット順序入れ替えの影響

### ファイル
`figures/p_reorder_legit.png`

### 実験の背景

**問題意識**：
現実の無線通信では、フレームが送信順と異なる順序で到着することがあります（順序入れ替え）。この現象が各防御手法にどのような影響を与えるかを測定します。

**実験設定**：
- 試行回数：200回（Monte Carlo法）
- 正規フレーム数：20個/試行
- パケット損失率：p_loss = 0（損失なし、純粋に順序入れ替えの影響を測定）
- パケット順序入れ替え率：p_reorder = 0.0, 0.1, 0.3, 0.5, 0.7
- 評価対象：Rolling Counter vs Sliding Window (W=5)

---

### 軸の解説

#### 横軸（X軸）：p_reorder（パケット順序入れ替え確率）

**意味**：
各フレームが遅延する確率。

**具体例**：
- `p_reorder = 0.0`：完璧なネットワーク（すべてのフレームが順番通り）
- `p_reorder = 0.1`：10個のフレームのうち1個が1-3ティック遅延
- `p_reorder = 0.3`：10個のフレームのうち3個が遅延（現実的な Wi-Fi 環境）
- `p_reorder = 0.5`：半分のフレームが遅延（非常に不安定）
- `p_reorder = 0.7`：70%のフレームが遅延（極度に不安定、ほぼ使用不可能）

**実装詳細**（`sim/channel.py`）：
```python
if self.rng.random() < self.p_reorder:
    delay = self.rng.randint(1, 3)  # 1-3ティックランダムに遅延
else:
    delay = 0  # 遅延なし
```

---

#### 縦軸（Y軸）：Legitimate Acceptance Rate（正規受理率、%）

**定義**：
$$
\text{Legitimate Acceptance Rate} = \frac{\text{受理された正規フレーム数}}{\text{送信した正規フレーム数}} \times 100\%
$$

**意味**：
正当なユーザーの操作が受信側で承認される割合。**ユーザビリティ指標**。

**具体例**：
- `100%`：すべての正規フレームが受理（理想的）
  - ユーザー視点：「操作が毎回成功する」
- `95%`：20フレーム中19フレームが受理（実用的）
  - ユーザー視点：「たまに失敗するが許容範囲」
- `84%`：20フレーム中約17フレームが受理
  - ユーザー視点：「5回に1回失敗する、イライラする」
- `50%`：半分が受理
  - ユーザー視点：「半分の操作が失敗、システムが壊れていると感じる」
- `0%`：すべてが拒否（システム使用不可）

**測定方法**（`sim/experiment.py`）：
```python
# 各試行で測定
accepted_legit = 0
for frame in legitimate_frames:
    result = receiver.verify(frame)
    if result.accepted:
        accepted_legit += 1

legit_rate = accepted_legit / len(legitimate_frames)
```

---

### プロットされている線

#### 青線（丸マーカー）：Rolling Counter

**挙動**：
- `p_reorder = 0.0`：100%（完璧）
- `p_reorder = 0.1`：93.55%（6.45%低下）
- `p_reorder = 0.3`：84.47%（**15.53%低下**）← 重要
- `p_reorder = 0.5`：77.62%（22.38%低下）
- `p_reorder = 0.7`：78.33%（21.67%低下）

**なぜこのような低下が起こるのか？**

**メカニズム解説**：
```
送信側：Counter = 0, 1, 2, 3, 4, 5, ...

理想的なケース（p_reorder=0）：
  受信順：0 → 1 → 2 → 3 → 4 → 5
  結果  ：✅   ✅   ✅   ✅   ✅   ✅ （すべて受理）

順序入れ替えケース（p_reorder=0.3）：
  送信順：0, 1, 2, 3, 4, 5
  受信順：0 → 2 → 1 → 4 → 3 → 5
          ✅   ✅   ❌   ✅   ❌   ✅
  
  詳細：
    - Counter=0 到着 → Last=-1, 0>-1 ✅ 受理、Last=0
    - Counter=2 到着 → Last=0, 2>0 ✅ 受理、Last=2
    - Counter=1 到着 → Last=2, 1<2 ❌ 拒否（誤検出！）
    - Counter=4 到着 → Last=2, 4>2 ✅ 受理、Last=4
    - Counter=3 到着 → Last=4, 3<4 ❌ 拒否（誤検出！）
    - Counter=5 到着 → Last=4, 5>4 ✅ 受理、Last=5
  
  正規受理率 = 4/6 = 66.7%
```

Rolling Counter は「Last Counter より大きいカウンタのみ受理」という単純なルールのため、遅れて到着した正規フレームを誤って拒否してしまいます。

---

#### オレンジ線（三角マーカー）：Sliding Window (W=5)

**挙動**：
- `p_reorder = 0.0`：100%（完璧）
- `p_reorder = 0.1`：100%（影響なし）
- `p_reorder = 0.3`：99.88%（わずか0.12%低下）
- `p_reorder = 0.5`：99.88%（安定）
- `p_reorder = 0.7`：99.90%（依然として高い）

**なぜ Rolling より優れているのか？**

**メカニズム解説**：
```
送信側：Counter = 0, 1, 2, 3, 4, 5, ...
Window Size = 5

順序入れ替えケース：
  送信順：0, 1, 2, 3, 4, 5
  受信順：0 → 2 → 1 → 4 → 3 → 5
  
  詳細：
    - Counter=0 到着：
      Last=-1 → 初期状態 ✅ 受理
      Last=0, Mask=0b1
    
    - Counter=2 到着：
      diff=2-0=2 > 0 → 新しいカウンタ ✅ 受理
      Mask <<= 2  →  0b100
      Mask |= 1   →  0b101 (bit 0=Counter 2, bit 2=Counter 0)
      Last=2
    
    - Counter=1 到着：
      diff=1-2=-1 ≤ 0 → 古いカウンタ（順序入れ替え）
      offset=2-1=1
      offset < window_size (1<5) ✅ ウィンドウ内
      (Mask >> 1) & 1 = (0b101 >> 1) & 1 = 0b10 & 1 = 0 ✅ 未受信
      Mask |= (1 << 1) = 0b101 | 0b10 = 0b111 ✅ 受理
    
    - Counter=4 到着：
      diff=4-2=2 > 0 → 新しいカウンタ ✅ 受理
      Mask <<= 2 → 0b11100
      Mask |= 1  → 0b11101
      Last=4
    
    - Counter=3 到着：
      diff=3-4=-1 ≤ 0 → 古いカウンタ
      offset=4-3=1
      offset < window_size ✅ ウィンドウ内
      (Mask >> 1) & 1 = 0 ✅ 未受信
      Mask |= (1 << 1) ✅ 受理
    
    - Counter=5 到着：
      diff=5-4=1 > 0 ✅ 受理
  
  正規受理率 = 6/6 = 100%
```

Sliding Window は「ウィンドウ範囲内のカウンタ」を許容し、ビットマスクで受信済みかチェックするため、遅れて到着した正規フレームも正しく受理できます。

---

### エラーバー（縦線）の意味

**定義**：
各データポイントに付いている縦線は**標準偏差（Standard Deviation）**を示します。

**計算方法**：
```python
# 200回の試行から
legit_rates = [試行1の正規受理率, 試行2の正規受理率, ..., 試行200の正規受理率]

平均 = mean(legit_rates)       # 例：84.47%
標準偏差 = stdev(legit_rates)  # 例：2.5%
```

**意味**：
- **エラーバーが短い**：試行間のバラツキが小さい = 結果が**安定**
  - 例：全200回の試行で 83%〜86% の範囲に収まる
  - 信頼性が高い
- **エラーバーが長い**：試行間のバラツキが大きい = 結果が**不安定**
  - 例：あ
